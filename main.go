package main

////////////////////////////////////////////////////////////////////////////////

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"text/template"
)

////////////////////////////////////////////////////////////////////////////////

const (
	tmpl = `// Warning: This file is generated by the gover tool. Do not edit!
// Version: {{ .Major }}.{{ .Minor }}.{{ .Patch }}
package {{ .PackageName }}

const (
    Major = {{ .Major }}
    Minor = {{ .Minor }}
    Patch = {{ .Patch }}

    Version = "{{ .Major }}.{{ .Minor }}.{{ .Patch }}"
)
`
	versionKey     = "// Version: "
	defaultVersion = "0.0.1"
)

////////////////////////////////////////////////////////////////////////////////

type version struct {
	Major uint64
	Minor uint64
	Patch uint64
}

func (v *version) unmarshal(s string) error {
	var err error

	items := strings.Split(s, ".")
	if len(items) < 3 {
		return fmt.Errorf("%s is an invalid version", s)
	}

	v.Major, err = strconv.ParseUint(items[0], 10, 64)
	if err != nil {
		return err
	}

	v.Minor, err = strconv.ParseUint(items[1], 10, 64)
	if err != nil {
		return err
	}

	v.Patch, err = strconv.ParseUint(items[2], 10, 64)
	return err
}

func (v *version) update() error {
	t, err := template.New("gover").Parse(tmpl)
	if err != nil {
		return err
	}

	f, err := os.Create("version_gen.go")
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, &context{
		version:     v,
		PackageName: "main",
	})
}

func fromFile() (*version, error) {
	bs, err := ioutil.ReadFile("version_gen.go")
	if err != nil {
		return nil, err
	}

	fc := string(bs)
	if idx := strings.Index(fc, versionKey); idx > 0 {
		ver := fc[idx+len(versionKey):]
		if idx = strings.Index(ver, "\n"); idx > 0 {
			ver = ver[:idx]
		}

		v := &version{}
		return v, v.unmarshal(ver)
	}

	return nil, errors.New("version not found in gen file")
}

////////////////////////////////////////////////////////////////////////////////

type context struct {
	*version
	PackageName string
}

////////////////////////////////////////////////////////////////////////////////

func initFn(s string) error {
	var v version
	if err := v.unmarshal(s); err != nil {
		return err
	}

	return v.update()
}

func versFn() error {
	v, err := fromFile()
	if err != nil {
		return err
	}

	fmt.Printf("Version: %d.%d.%d\n", v.Major, v.Minor, v.Patch)
	return nil
}

func incrFn(inc string) error {
	v, err := fromFile()
	if err != nil {
		return err
	}

	switch inc {
	case "major":
		fmt.Printf("Major incremented.\n")
		v.Major += 1
		v.Minor = 0
		v.Patch = 0
	case "minor":
		fmt.Printf("Minor incremented.\n")
		v.Minor += 1
		v.Patch = 0
	case "patch":
		fmt.Printf("Patch incremented.\n")
		v.Patch += 1
	default:
		return fmt.Errorf("cannot increment %s", inc)
	}

	return v.update()
}

////////////////////////////////////////////////////////////////////////////////

func main() {
	var (
		err error
		pv  bool
	)

	cmd := "version"
	if len(os.Args) >= 2 {
		cmd = strings.ToLower(os.Args[1])
	}

	switch cmd {
	case "init":
		v := defaultVersion
		if len(os.Args) >= 3 {
			v = os.Args[2]
		}
		err = initFn(v)
	case "version", "vers":
		pv = true
	case "increment", "inc":
		o := "patch"
		if len(os.Args) >= 3 {
			o = strings.ToLower(os.Args[2])
		}
		err = incrFn(o)
		if err == nil {
			pv = true
		}
	default:
		err = fmt.Errorf("%s is an invalid command", cmd)
	}

	if err == nil && pv == true {
		err = versFn()
	}

	if err != nil {
		fmt.Printf("Fatal error: %s\n", err.Error())
		os.Exit(1)
	}
}

////////////////////////////////////////////////////////////////////////////////
